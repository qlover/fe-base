# Internationalization (i18n)

## üìã Table of Contents

- [Core Philosophy](#-core-philosophy) - Never hard-code, use variables only
- [What is an i18n Key](#-what-is-an-i18n-key) - Unique identifier
- [Why Use i18n Keys](#-why-use-i18n-keys) - Reduce cognitive burden
- [Implementation in the Project](#-implementation-in-the-project) - Bootstrap plugin
- [How to Use](#-how-to-use) - Practical guide
- [Best Practices](#-best-practices) - 7 core practices
- [FAQ](#-faq) - Common questions

---

## üéØ Core Philosophy

> **üö® Important Principle: All text, words, and sentences that need to be displayed in the project must use i18n Keys. Hard-coded text is absolutely not allowed!**

> **‚≠ê Core Advantage: Developers don't need to remember complex translation strings, just variable names. The IDE will provide auto-completion!**

### Core Concept

```
‚ùå Hard-coded text        ‚úÖ i18n Key (variable)
"Login"            ‚Üí   BUTTON_LOGIN (no need to remember 'common:button.login')
"Welcome back"     ‚Üí   MESSAGE_WELCOME (no need to remember 'common:message.welcome')
"Are you sure?"    ‚Üí   CONFIRM_DELETE (no need to remember 'common:confirm.delete')
```

**Every text has a unique identifier:**

```typescript
// ‚ùå Wrong: Write text directly or use strings
<button>Login</button>
<h1>Welcome back</h1>
<p>{t('common:confirm.delete')}</p>  // Don't write strings either

// ‚úÖ Correct: Use i18n Key variables
<button>{t(BUTTON_LOGIN)}</button>       // Just remember the variable name
<h1>{t(MESSAGE_WELCOME)}</h1>            // IDE will auto-complete
<p>{t(CONFIRM_DELETE)}</p>               // TypeScript will check spelling
```

---

## üîë What is an i18n Key

An i18n Key is **a unique identifier for each text**, just like everyone has an ID number.

### Basic Concept

```typescript
// i18n Key definition (in config/Identifier/ directory)

/**
 * @description Login button text
 * @localZh ÁôªÂΩï
 * @localEn Login
 */
export const BUTTON_LOGIN = 'common:button.login';
//            ‚Üë Constant name            ‚Üë Identifier string
//            Used in code               Key name stored in translation files

/**
 * @description Welcome message
 * @localZh Ê¨¢ËøéÂõûÊù•Ôºå{{name}}ÔºÅ
 * @localEn Welcome back, {{name}}!
 */
export const MESSAGE_WELCOME = 'common:message.welcome';
```

**Structure explanation:**

```
'common:button.login'
   ‚Üë      ‚Üë      ‚Üë
Namespace Category Specific identifier
```

### Naming Conventions

```typescript
// ‚úÖ Good naming: Clear and structured
export const BUTTON_LOGIN = 'common:button.login'; // Button text
export const BUTTON_SUBMIT = 'common:button.submit'; // Button text
export const MESSAGE_WELCOME = 'common:message.welcome'; // Message text
export const CONFIRM_DELETE = 'common:confirm.delete'; // Confirm dialog
export const ERROR_NETWORK = 'common:error.network'; // Error message
export const PAGE_HOME_TITLE = 'common:page.home.title'; // Page title

// ‚ùå Bad naming: Vague and unstructured
export const TEXT1 = 'login';
export const MSG = 'welcome';
export const DELETE_CONFIRM = 'delete_confirm';
```

---

## ü§î Why Use i18n Keys

### Problem: Pain Points of Hard-coded Text

```typescript
// ‚ùå Traditional approach: Hard-coded text

function LoginPage() {
  return (
    <div>
      <h1>Login</h1>
      <button>Login</button>
      <p>Welcome back!</p>
      <span>Forgot password?</span>
    </div>
  );
}

// üò∞ Problem 1: Difficult to internationalize
// If we need to support Chinese, need to modify lots of code

// üò∞ Problem 2: Hard to maintain
// Same text might be used in multiple places, easy to miss when changing

// üò∞ Problem 3: Hard to manage uniformly
// Can't count how many texts exist in the project, which need translation

// üò∞ Problem 4: Hard to search
// To find where a text is used, can only globally search strings
```

### Solution: Use i18n Keys

```typescript
// ‚úÖ Use i18n Keys

import { useAppTranslation } from '@/uikit/hooks/useAppTranslation';
import {
  PAGE_LOGIN_TITLE,
  BUTTON_LOGIN,
  MESSAGE_WELCOME,
  LINK_FORGOT_PASSWORD
} from '@config/Identifier';

function LoginPage() {
  const { t } = useAppTranslation();

  return (
    <div>
      <h1>{t(PAGE_LOGIN_TITLE)}</h1>
      <button>{t(BUTTON_LOGIN)}</button>
      <p>{t(MESSAGE_WELCOME)}</p>
      <span>{t(LINK_FORGOT_PASSWORD)}</span>
    </div>
  );
}

// ‚úÖ Advantage 1: Automatic internationalization
// Automatically displays corresponding text based on user language

// ‚úÖ Advantage 2: Centralized management
// All text managed uniformly in Identifier files

// ‚úÖ Advantage 3: Easy to maintain
// Only need to modify in one place

// ‚úÖ Advantage 4: Type safe
// TypeScript will check if Key exists

// ‚úÖ Advantage 5: Reduce thinking ‚≠ê
// Developers only need to know BUTTON_LOGIN is a variable
// Don't need to remember 'common:button.login' string
// IDE will provide auto-completion, wrong spelling will immediately error
```

### Comparison Summary

| Feature                  | Hard-coded Text                    | i18n Key                             |
| ------------------------ | ---------------------------------- | ------------------------------------ |
| **Internationalization** | ‚ùå Difficult (need to change code) | ‚úÖ Automatic (just switch language)  |
| **Maintainability**      | ‚ùå Poor (scattered everywhere)     | ‚úÖ Good (centralized management)     |
| **Reusability**          | ‚ùå Poor (copy-paste)               | ‚úÖ Good (reference Key)              |
| **Searchability**        | ‚ùå Difficult (string search)       | ‚úÖ Simple (search constant)          |
| **Countability**         | ‚ùå Impossible                      | ‚úÖ Easy (count Keys)                 |
| **Type Safety**          | ‚ùå None                            | ‚úÖ Yes (TypeScript)                  |
| **Cognitive Burden**     | ‚ùå High (need to remember text)    | ‚úÖ Low (just remember variable name) |
| **IDE Support**          | ‚ùå No auto-complete                | ‚úÖ Full auto-complete                |

### ‚≠ê Core Advantage: Reduce Developer Thinking

**The most important advantage: Developers don't need to care about what the actual i18n string is!**

```typescript
// ‚ùå Traditional approach: Need to remember complex strings
function LoginPage() {
  const { t } = useTranslation();

  return (
    <div>
      {/* üò∞ Need to remember 'common:button.login' */}
      <button>{t('common:button.login')}</button>

      {/* üò∞ Need to remember 'page.login.title' */}
      <h1>{t('page.login.title')}</h1>

      {/* üò∞ Spelling mistake won't error */}
      <p>{t('page.login.welcom')}</p>  {/* welcom ‚Üí welcome, spelling error */}
    </div>
  );
}

// ‚úÖ i18n Key approach: Just need to know variable name
import { BUTTON_LOGIN, PAGE_LOGIN_TITLE, PAGE_LOGIN_WELCOME } from '@config/Identifier';

function LoginPage() {
  const { t } = useAppTranslation();

  return (
    <div>
      {/* ‚úÖ Just remember BUTTON_LOGIN, IDE will auto-complete */}
      <button>{t(BUTTON_LOGIN)}</button>

      {/* ‚úÖ Type PAGE_ and IDE will show all available Keys */}
      <h1>{t(PAGE_LOGIN_TITLE)}</h1>

      {/* ‚úÖ Wrong spelling will immediately error in TypeScript */}
      <p>{t(PAGE_LOGIN_WELCOM)}</p>  {/* ‚ùå TS error: Variable not found */}
    </div>
  );
}
```

**Development Experience Comparison:**

```typescript
// ‚ùå Using strings workflow:
// 1. üò∞ Check translation files, find corresponding key
// 2. üò∞ Remember complete key path (like 'common:page.login.title')
// 3. üò∞ Manually type the string in code
// 4. üò∞ May type incorrectly, but compiler won't error
// 5. üò∞ Only discover translation didn't work at runtime

// ‚úÖ Using i18n Key workflow:
// 1. üòä Type variable name prefix (like BUTTON_)
// 2. üòä IDE automatically suggests all available Keys
// 3. üòä Select needed Key, IDE auto-completes
// 4. üòä If typed incorrectly, TypeScript immediately errors
// 5. üòä Can ensure Key correctness at compile time
```

**Cognitive Burden Comparison:**

| What Developers Need to Remember | String Method                                 | i18n Key Method                |
| -------------------------------- | --------------------------------------------- | ------------------------------ |
| **Translation File Structure**   | ‚úÖ Must remember (like `common:button.login`) | ‚ùå Don't need to               |
| **Namespace**                    | ‚úÖ Must remember (like `common:`, `page:`)    | ‚ùå Don't need to               |
| **String Path**                  | ‚úÖ Must remember complete path                | ‚ùå Don't need to               |
| **Variable Name**                | ‚ùå No variable                                | ‚úÖ Just remember variable name |
| **IDE Hints**                    | ‚ùå None                                       | ‚úÖ Full hints                  |

**Real Development Scenarios:**

```typescript
// Scenario 1: Write a new button

// ‚ùå String method (need to think a lot)
// 1. What should this button's translation key be called?
// 2. Which namespace should it go in? common? page?
// 3. What should the path be? button.submit? submit.button?
// 4. Finally write: t('common:button.submit')
<button>{t('common:button.submit')}</button>

// ‚úÖ i18n Key method (just need to search)
// 1. Type BUTTON_
// 2. IDE shows all available button Keys
// 3. See BUTTON_SUBMIT, select it
// 4. Done!
<button>{t(BUTTON_SUBMIT)}</button>

// Scenario 2: Change text on another page

// ‚ùå String method
// 1. Check that page's code
// 2. Find t('page.home.welcome')
// 3. Remember this string
// 4. Search and modify in translation files

// ‚úÖ i18n Key method
// 1. See PAGE_HOME_WELCOME in code
// 2. Jump directly to definition (IDE's Go to Definition)
// 3. Modify translation in comment
// 4. Automatically generate new translation files
```

**Summary:**

Using i18n Keys allows developers to:

- ‚úÖ **Don't need to remember** complex string paths
- ‚úÖ **Don't need to remember** translation file structure
- ‚úÖ **Don't need to care about** specific translation key names
- ‚úÖ **Just need to know** this is a variable
- ‚úÖ **Rely on IDE** provided auto-complete and type checking
- ‚úÖ **Focus on** business logic, not translation details

> üí° **Core Philosophy: Let developers put their energy into business logic, not memorizing translation strings!**

---

## üõ†Ô∏è Implementation in the Project

### 1. File Structure

```
config/
‚îî‚îÄ‚îÄ Identifier/           # i18n Key definition directory
    ‚îú‚îÄ‚îÄ index.ts          # Export all Keys
    ‚îú‚îÄ‚îÄ common/           # Common text
    ‚îÇ   ‚îú‚îÄ‚îÄ index.ts
    ‚îÇ   ‚îú‚îÄ‚îÄ common.ts     # General text (buttons, messages, etc.)
    ‚îÇ   ‚îî‚îÄ‚îÄ common.error.ts # Error messages
    ‚îî‚îÄ‚îÄ pages/            # Page text
        ‚îú‚îÄ‚îÄ index.ts
        ‚îú‚îÄ‚îÄ page.home.ts  # Home page text
        ‚îú‚îÄ‚îÄ page.login.ts # Login page text
        ‚îî‚îÄ‚îÄ page.about.ts # About page text

public/
‚îî‚îÄ‚îÄ locales/              # Generated translation files
    ‚îú‚îÄ‚îÄ zh/
    ‚îÇ   ‚îî‚îÄ‚îÄ common.json   # Chinese translations
    ‚îî‚îÄ‚îÄ en/
        ‚îî‚îÄ‚îÄ common.json   # English translations

src/
‚îî‚îÄ‚îÄ uikit/
    ‚îî‚îÄ‚îÄ hooks/
        ‚îî‚îÄ‚îÄ useAppTranslation.ts  # Translation Hook
```

### 2. i18n Configuration

```typescript
// config/i18n/i18nConfig.ts
export const i18nConfig = {
  fallbackLng: 'en', // Default language
  debug: false,
  interpolation: {
    escapeValue: false
  },
  ns: ['common'], // Namespaces
  defaultNS: 'common',
  backend: {
    loadPath: '/locales/{{lng}}/{{ns}}.json' // Translation file path
  },
  supportedLngs: ['en', 'zh'] // Supported languages
} as const;
```

### 3. I18nService (Bootstrap Plugin)

```typescript
// src/base/services/I18nService.ts
export class I18nService implements BootstrapExecutorPlugin {
  readonly pluginName = 'I18nService';

  constructor(protected pathname: string) {
    super(() => new I18nServiceState(i18n.language));
  }

  /**
   * Initialize i18n on Bootstrap startup
   */
  onBefore(): void {
    i18n
      .use(HttpApi) // Load translation files
      .use(LanguageDetector) // Language detection
      .use(initReactI18next) // React integration
      .init(i18nConfig); // Initialize config

    // Add custom language detector (detect from URL path)
    const pathLanguageDetector = {
      name: 'pathLanguageDetector',
      lookup: () => {
        const paths = this.pathname.split('/');
        for (const path of paths) {
          if (this.isValidLanguage(path)) {
            return path; // Extract language from URL (like /zh/home)
          }
        }
        return fallbackLng;
      },
      cacheUserLanguage(lng: string) {
        localStorage.setItem('i18nextLng', lng);
      }
    };

    i18n.services.languageDetector.addDetector(pathLanguageDetector);
  }

  /**
   * Switch language
   */
  async changeLanguage(language: string): Promise<void> {
    await i18n.changeLanguage(language);
    localStorage.setItem('i18nextLng', language);
  }

  /**
   * Translate text
   */
  t(key: string, params?: Record<string, unknown>): string {
    return i18n.t(key, { lng: i18n.language, ...params });
  }
}
```

### 4. Auto-generate Translation Files

```typescript
// vite.config.ts
import ts2Locales from '@brain-toolkit/ts2locales/vite';

export default defineConfig({
  plugins: [
    // ‚úÖ ts2locales plugin: Auto-generate translation files from TypeScript comments
    ts2Locales({
      locales: ['en', 'zh'],
      options: generateTs2LocalesOptions() // Configure generation rules
    })
  ]
});
```

**How it works:**

```typescript
// 1. Define Key in Identifier file
/**
 * @description Login button text
 * @localZh ÁôªÂΩï
 * @localEn Login
 */
export const BUTTON_LOGIN = 'common:button.login';

// 2. ts2locales plugin automatically generates translation files

// public/locales/zh/common.json
{
  "button": {
    "login": "ÁôªÂΩï"
  }
}

// public/locales/en/common.json
{
  "button": {
    "login": "Login"
  }
}
```

---

## üìù How to Use

### 1. Define i18n Key

```typescript
// config/Identifier/pages/page.home.ts

/**
 * @description Home page title
 * @localZh È¶ñÈ°µ
 * @localEn Home
 */
export const PAGE_HOME_TITLE = 'common:page.home.title';

/**
 * @description Home page welcome message
 * @localZh Ê¨¢ËøéÊù•Âà∞Êàë‰ª¨ÁöÑÂ∫îÁî®ÔºÅ
 * @localEn Welcome to our application!
 */
export const PAGE_HOME_WELCOME = 'common:page.home.welcome';

/**
 * @description Home page description with user name
 * @localZh ‰Ω†Â•ΩÔºå{{name}}ÔºÅ‰ªäÂ§©ÊòØ‰∏™Â•ΩÊó•Â≠ê„ÄÇ
 * @localEn Hello, {{name}}! Have a great day.
 */
export const PAGE_HOME_GREETING = 'common:page.home.greeting';
```

**Comment conventions:**

- `@description`: Explain text purpose (English)
- `@localZh`: Chinese translation
- `@localEn`: English translation

### 2. Use in UI Components

```typescript
// src/pages/base/HomePage.tsx
import { useAppTranslation } from '@/uikit/hooks/useAppTranslation';
import {
  PAGE_HOME_TITLE,
  PAGE_HOME_WELCOME,
  PAGE_HOME_GREETING
} from '@config/Identifier';

function HomePage() {
  const { t } = useAppTranslation();
  const userName = 'John';

  return (
    <div>
      {/* ‚úÖ Simple text */}
      <h1>{t(PAGE_HOME_TITLE)}</h1>
      <p>{t(PAGE_HOME_WELCOME)}</p>

      {/* ‚úÖ Text with parameters */}
      <p>{t(PAGE_HOME_GREETING, { name: userName })}</p>
    </div>
  );
}
```

### 3. Use in Services

```typescript
// src/base/services/UserService.ts
import { injectable, inject } from 'inversify';
import { I18nServiceInterface } from '@/base/port/I18nServiceInterface';
import { ERROR_USER_NOT_FOUND } from '@config/Identifier';

@injectable()
export class UserService {
  constructor(
    @inject(IOCIdentifier.I18nServiceInterface)
    private i18n: I18nServiceInterface
  ) {}

  async getUser(id: string) {
    const user = await this.api.getUserById(id);

    if (!user) {
      // ‚úÖ Use i18n in service
      throw new Error(this.i18n.t(ERROR_USER_NOT_FOUND, { id }));
    }

    return user;
  }
}
```

### 4. Switch Language

```typescript
// src/uikit/components/LanguageSwitcher.tsx
import { useIOC } from '@/uikit/hooks/useIOC';

function LanguageSwitcher() {
  const i18nService = useIOC('I18nServiceInterface');
  const currentLang = i18nService.getCurrentLanguage();

  const handleChange = (lang: 'zh' | 'en') => {
    // ‚úÖ Switch language
    i18nService.changeLanguage(lang);
  };

  return (
    <select value={currentLang} onChange={(e) => handleChange(e.target.value)}>
      <option value="zh">‰∏≠Êñá</option>
      <option value="en">English</option>
    </select>
  );
}
```

### 5. Complex Scenarios

#### Scenario 1: Dynamic Text

```typescript
/**
 * @description Upload progress message
 * @localZh Â∑≤‰∏ä‰º† {{current}} / {{total}} ‰∏™Êñá‰ª∂
 * @localEn Uploaded {{current}} / {{total}} files
 */
export const UPLOAD_PROGRESS = 'common:upload.progress';

// Usage
<p>{t(UPLOAD_PROGRESS, { current: 3, total: 10 })}</p>
// Chinese: Â∑≤‰∏ä‰º† 3 / 10 ‰∏™Êñá‰ª∂
// English: Uploaded 3 / 10 files
```

#### Scenario 2: Plural Forms

```typescript
/**
 * @description Files count message
 * @localZh {{count}} ‰∏™Êñá‰ª∂
 * @localEn {{count}} file_plural
 */
export const FILES_COUNT = 'common:files.count';

// Usage
<p>{t(FILES_COUNT, { count: 1 })}</p>  // 1 file
<p>{t(FILES_COUNT, { count: 5 })}</p>  // 5 files
```

#### Scenario 3: HTML Content

```typescript
/**
 * @description Terms of service agreement
 * @localZh ÊàëÂ∑≤ÈòÖËØªÂπ∂ÂêåÊÑè<a href="/terms">ÊúçÂä°Êù°Ê¨æ</a>
 * @localEn I have read and agree to the <a href="/terms">Terms of Service</a>
 */
export const TERMS_AGREEMENT = 'common:terms.agreement';

// Usage (Need to use Trans component in React)
import { Trans } from 'react-i18next';

<Trans i18nKey={TERMS_AGREEMENT}>
  I have read and agree to the <a href="/terms">Terms of Service</a>
</Trans>
```

---

## üíé Best Practices

### 1. ‚úÖ All Text Uses i18n Keys

```typescript
// ‚ùå Wrong: Mix hard-coded and i18n Keys
function LoginForm() {
  return (
    <form>
      <h1>{t(PAGE_LOGIN_TITLE)}</h1>
      <button>Login</button>  {/* ‚ùå Hard-coded */}
      <a href="/forgot">Forgot password?</a>  {/* ‚ùå Hard-coded */}
    </form>
  );
}

// ‚úÖ Correct: All text uses i18n Keys
function LoginForm() {
  return (
    <form>
      <h1>{t(PAGE_LOGIN_TITLE)}</h1>
      <button>{t(BUTTON_LOGIN)}</button>  {/* ‚úÖ Use Key */}
      <a href="/forgot">{t(LINK_FORGOT_PASSWORD)}</a>  {/* ‚úÖ Use Key */}
    </form>
  );
}
```

### 2. ‚úÖ Organize i18n Keys Reasonably

```typescript
// ‚úÖ Good organization: Categorize by functional modules
config/Identifier/
‚îú‚îÄ‚îÄ common/
‚îÇ   ‚îú‚îÄ‚îÄ common.ts           # General text (buttons, labels, etc.)
‚îÇ   ‚îî‚îÄ‚îÄ common.error.ts     # Error messages
‚îú‚îÄ‚îÄ pages/
‚îÇ   ‚îú‚îÄ‚îÄ page.home.ts        # Home page text
‚îÇ   ‚îú‚îÄ‚îÄ page.login.ts       # Login page text
‚îÇ   ‚îî‚îÄ‚îÄ page.about.ts       # About page text
‚îî‚îÄ‚îÄ components/
    ‚îú‚îÄ‚îÄ component.header.ts # Header component text
    ‚îî‚îÄ‚îÄ component.footer.ts # Footer component text
```

### 3. ‚úÖ Use Semantic Naming

```typescript
// ‚úÖ Good naming: Clearly expresses meaning
export const BUTTON_SUBMIT = 'common:button.submit';
export const BUTTON_CANCEL = 'common:button.cancel';
export const ERROR_NETWORK = 'common:error.network';
export const MESSAGE_SUCCESS = 'common:message.success';

// ‚ùå Bad naming: Unclear meaning
export const BTN1 = 'btn1';
export const TEXT = 'text';
export const MSG = 'msg';
```

### 4. ‚úÖ Add Clear Comments to i18n Keys

```typescript
// ‚úÖ Good comments: Clearly explain purpose and context
/**
 * @description Confirmation message when user tries to delete an item
 * @localZh Á°ÆÂÆöË¶ÅÂà†Èô§ {{itemName}} ÂêóÔºüÊ≠§Êìç‰Ωú‰∏çÂèØÊí§ÈîÄ„ÄÇ
 * @localEn Are you sure you want to delete {{itemName}}? This action cannot be undone.
 */
export const CONFIRM_DELETE_ITEM = 'common:confirm.delete.item';

// ‚ùå Bad comments: No context information
/**
 * @description Delete
 * @localZh Âà†Èô§
 * @localEn Delete
 */
export const DELETE = 'delete';
```

### 5. ‚úÖ Unified Naming Conventions

```typescript
// ‚úÖ Recommended naming conventions:

// Button text
export const BUTTON_LOGIN = 'common:button.login';
export const BUTTON_SUBMIT = 'common:button.submit';
export const BUTTON_CANCEL = 'common:button.cancel';

// Page titles
export const PAGE_HOME_TITLE = 'common:page.home.title';
export const PAGE_ABOUT_TITLE = 'common:page.about.title';

// Error messages
export const ERROR_NETWORK = 'common:error.network';
export const ERROR_INVALID_INPUT = 'common:error.invalid.input';

// Message prompts
export const MESSAGE_SUCCESS = 'common:message.success';
export const MESSAGE_WARNING = 'common:message.warning';

// Confirm dialogs
export const CONFIRM_DELETE = 'common:confirm.delete';
export const CONFIRM_LOGOUT = 'common:confirm.logout';

// Link text
export const LINK_FORGOT_PASSWORD = 'common:link.forgot.password';
export const LINK_PRIVACY_POLICY = 'common:link.privacy.policy';
```

### 6. ‚úÖ Avoid Duplicate Definitions

```typescript
// ‚ùå Wrong: Duplicate definitions of same text
// config/Identifier/common/common.ts
export const BUTTON_OK_1 = 'common:button.ok1';

// config/Identifier/pages/page.home.ts
export const BUTTON_OK_2 = 'common:button.ok2';

// ‚úÖ Correct: Define once in common file, reference in multiple places
// config/Identifier/common/common.ts
export const BUTTON_OK = 'common:button.ok';

// Reference in various pages
import { BUTTON_OK } from '@config/Identifier';
```

### 7. ‚úÖ Use Parameterized Text

```typescript
// ‚ùå Bad: Define different Keys for each case
export const WELCOME_USER_JOHN = 'common:welcome.john';
export const WELCOME_USER_MARY = 'common:welcome.mary';

// ‚úÖ Good: Use parameters
/**
 * @description Welcome message with user name
 * @localZh Ê¨¢ËøéÔºå{{name}}ÔºÅ
 * @localEn Welcome, {{name}}!
 */
export const WELCOME_USER = 'common:welcome.user';

// Usage
<h1>{t(WELCOME_USER, { name: 'John' })}</h1>
<h1>{t(WELCOME_USER, { name: 'Mary' })}</h1>
```

---

## ‚ùì FAQ

### Q1: Why can't I write text directly?

**A:**

```typescript
// ‚ùå Problems with writing text directly
<button>Login</button>

// Problem 1: Cannot internationalize
// If user switches to Chinese, text won't change

// Problem 2: Hard to maintain
// If want to change "Login" to "Sign In", need to find all places to modify

// Problem 3: Cannot manage uniformly
// Can't know how many "Login" buttons exist in the project

// ‚úÖ Advantages of using i18n Key
<button>{t(BUTTON_LOGIN)}</button>

// ‚úÖ Automatic internationalization: Switch language to automatically show corresponding text
// ‚úÖ Easy to maintain: Only need to modify definition in one place
// ‚úÖ Unified management: All text centralized in Identifier files
```

### Q2: How to know where a Key is used?

**A:**

```bash
# Search constant name
grep -r "BUTTON_LOGIN" src/

# Or use "Find Usages" feature in IDE
# Can quickly find all places using this Key
```

### Q3: What if I forget to define an i18n Key?

**A:** TypeScript will error at compile time:

```typescript
// ‚ùå Using undefined Key
<button>{t(BUTTON_NOT_EXIST)}</button>
// TypeScript error: Cannot find name 'BUTTON_NOT_EXIST'

// ‚úÖ Correct: Define Key first
export const BUTTON_NOT_EXIST = 'common:button.not.exist';
```

### Q4: How to handle dynamic text?

**A:** Use parameters:

```typescript
/**
 * @description User greeting with name and time
 * @localZh {{name}}Ôºå{{time}}Â•ΩÔºÅ
 * @localEn Good {{time}}, {{name}}!
 */
export const GREETING_WITH_TIME = 'common:greeting.with.time';

// Usage
<h1>{t(GREETING_WITH_TIME, { name: 'John', time: 'morning' })}</h1>
// Chinese: JohnÔºåmorningÂ•ΩÔºÅ
// English: Good morning, John!
```

### Q5: How are translation files generated?

**A:**

```
1. Developer defines Keys and translation comments in Identifier files
   ‚Üì
2. ts2locales plugin scans TypeScript files
   ‚Üì
3. Extract @localZh and @localEn from comments
   ‚Üì
4. Auto-generate public/locales/{lng}/common.json
   ‚Üì
5. i18next loads these JSON files at runtime
```

### Q6: Can I use translated text directly in code?

**A:**

```typescript
// ‚ùå Not recommended: Skip i18n system
const loginText = 'Login';  // Hard-coded
<button>{loginText}</button>

// ‚úÖ Recommended: Always use i18n Key
const loginText = t(BUTTON_LOGIN);  // Through i18n system
<button>{loginText}</button>
```

### Q7: How to test i18n?

**A:**

```typescript
// __tests__/i18n.test.ts
import { I18nService } from '@/base/services/I18nService';
import { BUTTON_LOGIN } from '@config/Identifier';

describe('I18n', () => {
  let i18nService: I18nService;

  beforeEach(() => {
    i18nService = new I18nService('/zh/home');
    i18nService.onBefore();
  });

  it('should translate to Chinese', () => {
    i18nService.changeLanguage('zh');
    expect(i18nService.t(BUTTON_LOGIN)).toBe('ÁôªÂΩï');
  });

  it('should translate to English', () => {
    i18nService.changeLanguage('en');
    expect(i18nService.t(BUTTON_LOGIN)).toBe('Login');
  });

  it('should support parameters', () => {
    const result = i18nService.t(WELCOME_USER, { name: 'John' });
    expect(result).toContain('John');
  });
});
```

---

## üìö Related Documentation

- [Project Architecture Design](./index.md) - Understand overall architecture
- [Bootstrap Initializer](./bootstrap.md) - I18nService is one of the Bootstrap plugins
- [Configuration-Driven Development](./#configuration-driven-development) - i18n Key is a practice of configuration-driven development

---

## üéâ Summary

Core philosophy of the internationalization system:

1. **Unique Identifier** üîë - Every text has a unique i18n Key
2. **Never Hard-code** üö´ - All text in project must use i18n Keys
3. **Reduce Thinking** üß† - Developers only need to know variable names, don't need to remember string paths
4. **Centralized Management** üì¶ - All Key definitions in Identifier directory
5. **Auto-generation** ‚ö° - Translation files auto-generated from comments
6. **Type Safety** üîí - TypeScript provides complete type checking
7. **Easy to Maintain** üõ†Ô∏è - Only need to modify translation in one place
8. **IDE Friendly** üíª - Complete auto-completion and type hints

**Remember two core principles:**

1. **Never write text directly in code!**
2. **Developers don't need to remember translation strings, just variable names!**

```typescript
// ‚ùå Never do this
<button>Login</button>
<h1>Welcome back</h1>
<p>{t('common:confirm.delete')}</p>  // Don't write strings directly either

// ‚úÖ Always do this
<button>{t(BUTTON_LOGIN)}</button>
<h1>{t(MESSAGE_WELCOME)}</h1>
<p>{t(CONFIRM_DELETE)}</p>  // Use variables, IDE will auto-complete
```

**Development Workflow:**

```typescript
// 1. Type variable name prefix
t(BUTTON_

// 2. IDE automatically suggests all available Keys
// BUTTON_LOGIN
// BUTTON_SUBMIT
// BUTTON_CANCEL
// ...

// 3. Select needed Key, done!
t(BUTTON_LOGIN)

// Don't need to remember 'common:button.login'
// Don't need to care about translation file structure
// Don't need to worry about spelling errors (TypeScript will check)
```

---

**Feedback:**  
If you have any questions or suggestions about the internationalization system, please discuss in the team channel or submit an Issue.
